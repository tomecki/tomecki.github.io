{"html":"<p>There are countless tutorials on how to do NLP on the internet. Why would you care to read another one? Well, we will be looking into analysing Polish language, which is still rather underdeveloped in comparison to English. </p>\n<p>Polish language is much more complex when compared to English language, as it contains 7 cases  (<em>deklinacja</em>), 3 kinds (masculine, femenine, unspecified) and 11 different templates of verb conjugation, not to mention the exceptions <a href=\"#cite-1\">[1]</a> <a href=\"#cite-2\">[2]</a> <a href=\"#cite-3\">[3]</a>. English is rather simple: verb conjugation is easy, nouns pluralise easily, there are hardly any genders.</p>\n<h2 id=\"corpus\">Corpus</h2>\n<p>For the sake of this analysis, we will look at collection of articles obtained (the nice word for <em>scraped</em>) from one of the leading right-wing news websites, <a href=\"http://wpolityce.pl\">wpolityce.pl</a>.</p>\n<p><img src=\"/images/1-assets/fullarticle.png\" alt=\"Sample article\">\nSample article from the dataset.</p>\n<p>The articles were collected over a period of 15 days ending 10th June 2019, only articles linked from front page were collected. In total there are 1453 unique articles. I shall later publish my insights on collecting datasets from the wild.</p>\n<h2 id=\"tokenizing\">Tokenizing</h2>\n<p>Tokens are the smallest unit of the language that&#39;s most commonly taken into account when doing text analysis. You may think of it as a word, which in most cases it is. Things get trickier in English with it&#39;s abbreviations like <em>I&#39;d</em> or <em>we&#39;ve</em> but Polish is much easier in this aspect.</p>\n<pre class='language-javascriptreact'><code>„|Gazeta|Wyborcza|”|wielokrotnie|na| |swoich|łamach|wspierała|działania|Fundacji|Nie|lękajcie|się|Marka|Lisińskiego|.</code></pre><p>Sample tokenization of a sentence from the corpus, tokens are delimited with vertical bars. Please note empty token between words <em>na</em> and <em>swoich</em> - it&#39;s a dirty whitespace, which we&#39;ll deal with shortly.</p>\n<p>In Python, you can tokenize using either NLTK&#39;s <a href=\"https://www.nltk.org/api/nltk.tokenize.html\">nltk.tokenize</a> package or spaCy&#39;s <a href=\"https://spacy.io/api/tokenizer\">tokenizer</a> using pretrained language models. I have used the latter with <a href=\"https://spacy.io/models/xx#xx_ent_wiki_sm\">xx_ent_wiki_sm</a> multilanguage model. In empirical analysis it appeared to split up the tokens in a plausible manner.</p>\n<p><img src=\"/images/1-assets/article-token-length.png\" alt=\"The distribution of numbers of tokens for an article looks as follows:\n\"></p>\n<p>The distribution of numbers of tokens in an article: vertical axis shows number of articles falling into particular bucket, horizontal axis is the token lenght of article.</p>\n<h2 id=\"quantitative-analysis-corpus\">Quantitative analysis: corpus</h2>\n<p>Reading the entire dataset without any cleaning yields mediocre results. The resulting corpus contains:</p>\n<ul>\n<li>badly interpreted non-breaking space from latin1 encoding (<code>&quot;\\xa0&quot;</code>)</li>\n<li>whitespace-only tokens (<code>&quot;\\n&quot;</code>, <code>&quot;\\n \\n&quot;</code> and others)</li>\n<li>punctuation, also in repeated non-ambiguous way (multiple quote chars, hyphen/minus used interchangeably)</li>\n<li>stopwords: common words that skew the word distribution but do not bring any value to the analysis.</li>\n</ul>\n<h3 id=\"frequent-words-unigrams\">Frequent words (unigrams)</h3>\n<p><img src=\"/images/1-assets/clean-token-frequency.png\" alt=\"10 most frequent tokens in a clean dataset\"></p>\n<table>\n<thead>\n<tr>\n<th>word</th>\n<th>frequency</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PiS</td>\n<td>1444</td>\n</tr>\n<tr>\n<td>proc</td>\n<td>1198</td>\n</tr>\n<tr>\n<td>wyborach</td>\n<td>835</td>\n</tr>\n<tr>\n<td>powiedział</td>\n<td>726</td>\n</tr>\n<tr>\n<td>PAP</td>\n<td>709</td>\n</tr>\n<tr>\n<td>PSL</td>\n<td>676</td>\n</tr>\n<tr>\n<td>r.</td>\n<td>653</td>\n</tr>\n<tr>\n<td>Polski</td>\n<td>652</td>\n</tr>\n<tr>\n<td>Polsce</td>\n<td>625</td>\n</tr>\n<tr>\n<td>Europejskiej</td>\n<td>601</td>\n</tr>\n</tbody></table>\n<h4 id=\"word-cloud\">Word cloud</h4>\n<p>The raw data above can be visualised using a word cloud. The idea is to represent the frequency of the word with it&#39;s relative size on the visualisation, framing it in visually attractive and appealing way.</p>\n<p>You can find plenty of online generators that will easily let you tweak the shape, colors and fonts. Check out my wordcloud of 50 most common words from the corpus generated using generator from <a href=\"https://worditout.com\">worditout.com</a>\n<img src=\"/images/1-assets/wordcloud.png\" alt=\"Sample wordcloud\"></p>\n<p>Concluding our unigram analysis, the most common topics were revolving around PiS (abbreviation used by the polish ruling party), elections (<em>wyborach</em> stands for elections, <em>proc.</em> is abbreviated percent).</p>\n<h3 id=\"ngrams\">Ngrams</h3>\n<p>Ngram is just a sequence of <em>n</em> consecutive tokens. For <em>n=2</em> we also use word <em>bigram</em>. You can get the most frequent Ngrams (sequences of words of particilar length) using either <code>nltk.ngrams</code> or trivial custom code. For length 2-3 you are highly likely to fetch popular full names. Longer ngrams are likely to catch parts of frequently repeated sentences, like promos, ads and references.</p>\n<h4 id=\"bigrams\">Bigrams</h4>\n<p>As expected, we are catching frequent proper names of entities in the text. Below is a breakdown of 10 most frequent bigrams from the corpus:</p>\n<table>\n<thead>\n<tr>\n<th>frequency</th>\n<th>bigram</th>\n<th>interpretation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>377</td>\n<td>Koalicji Europejskiej</td>\n<td>political party</td>\n</tr>\n<tr>\n<td>348</td>\n<td>Parlamentu Europejskiego</td>\n<td>name of institution</td>\n</tr>\n<tr>\n<td>322</td>\n<td>PAP EOT</td>\n<td>source/author alias</td>\n</tr>\n<tr>\n<td>261</td>\n<td>4 czerwca</td>\n<td>important date discussed at the time</td>\n</tr>\n<tr>\n<td>223</td>\n<td>Koalicja Europejska</td>\n<td>political party</td>\n</tr>\n<tr>\n<td>136</td>\n<td>Andrzej Duda</td>\n<td>full name of President of Poland</td>\n</tr>\n<tr>\n<td>126</td>\n<td>Jarosław Kaczyński</td>\n<td>full name of important politician</td>\n</tr>\n<tr>\n<td>126</td>\n<td>Jana Pawła</td>\n<td>most likely: prefix from <em>John Paul II</em></td>\n</tr>\n<tr>\n<td>125</td>\n<td>Pawła II</td>\n<td>most likely: suffix from <em>John Paul II</em></td>\n</tr>\n</tbody></table>\n<h4 id=\"sixgrams\">Sixgrams</h4>\n<p>Longer ngrams expose frequent phrases used throughout the corpus. Polish has a lot of cases and persons, so this method is not of much help to find frequent phrases in the language itself; you are more likely to find repeated parts of sentences or adverts.</p>\n<table>\n<thead>\n<tr>\n<th>frequency</th>\n<th>sixgram</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>61</td>\n<td>Kup nasze pismo w kiosku lub</td>\n</tr>\n<tr>\n<td>61</td>\n<td>nasze pismo w kiosku lub skorzystaj</td>\n</tr>\n<tr>\n<td>61</td>\n<td>pismo w kiosku lub skorzystaj z</td>\n</tr>\n<tr>\n<td>61</td>\n<td>w kiosku lub skorzystaj z bardzo</td>\n</tr>\n<tr>\n<td>61</td>\n<td>kiosku lub skorzystaj z bardzo wygodnej</td>\n</tr>\n</tbody></table>\n<p>Clearly, there is an issue here. While doing our quantitative analysis our distributions and counts are skewed by the advert texts being present in most of the articles. Ideally we should factor these phrases out of our corpus, either at a stage of data collection (improving the parser to annotate/omit these phrase) or data preprocessing (something we&#39;re doing in this article).</p>\n<p>Much better idea is to perform ngrams analysis on lemmatized text. This way you may mine more knowledge about the language, not just repeated phrases.</p>\n<h2 id=\"morphological-analysis\">Morphological analysis</h2>\n<p>In the previous paragraph we saw that the different forms of the words will make learning about the language harder - we are capturing the information about the entire word, with the particular gender, tense and case. This becomes particularly disruptive in Polish. </p>\n<p>One potential solution is called <em>morphological analysis</em>. This is a process of mapping a word to all of it&#39;s potential dictionary base words (<em>lexems</em>). Sample lemmatization:</p>\n<table>\n<thead>\n<tr>\n<th>Original word</th>\n<th>Lemma tag</th>\n<th>Lexem</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Dyrektywa</td>\n<td>dyrektywa</td>\n<td>subst:sg:nom:f</td>\n</tr>\n<tr>\n<td>PSD2</td>\n<td>PSD2</td>\n<td>ign</td>\n</tr>\n<tr>\n<td>zawiera</td>\n<td>zawierać</td>\n<td>fin:sg:ter:imperf</td>\n</tr>\n<tr>\n<td>przepisy</td>\n<td>przepis</td>\n<td>subst:pl:nom:m3</td>\n</tr>\n<tr>\n<td>odnoszące</td>\n<td>odnosić</td>\n<td>pact:sg:nom:n:imperf:aff</td>\n</tr>\n<tr>\n<td>się</td>\n<td>się</td>\n<td>qub</td>\n</tr>\n<tr>\n<td>do</td>\n<td>do</td>\n<td>prep:gen</td>\n</tr>\n<tr>\n<td>płatności</td>\n<td>płatność</td>\n<td>subst:sg:gen:f</td>\n</tr>\n<tr>\n<td>elektronicznych</td>\n<td>elektroniczny</td>\n<td>adj:pl:gen:m1:pos</td>\n</tr>\n<tr>\n<td>realizowanych</td>\n<td>realizować</td>\n<td>ppas:pl:gen:m1:imperf:aff</td>\n</tr>\n<tr>\n<td>wewnątrz</td>\n<td>wewnątrz</td>\n<td>adv:pos</td>\n</tr>\n<tr>\n<td>Unii</td>\n<td>unia</td>\n<td>subst:sg:gen:f</td>\n</tr>\n<tr>\n<td>Europejskiej</td>\n<td>europejski</td>\n<td>adj:sg:gen:f:pos</td>\n</tr>\n<tr>\n<td>.</td>\n<td>.</td>\n<td>interp</td>\n</tr>\n</tbody></table>\n<p>We will not be implementing this part from scratch, instead we can use resources from IPI PAN (Polish Academy of Science), specifically a tool called <a href=\"http://morfeusz.sgjp.pl/\">Morfeusz</a>. </p>\n<p>Morfeusz is a morphosyntactic analyzer which you can use to find all word lexems and the forms. The output will be slightly different than the table above: instead, for every input word Morfeusz will output all of it&#39;s possible dictionary forms.</p>\n<h3 id=\"usage\">Usage</h3>\n<p>I assume you are running either a recent Ubuntu or Fedora. After fetching the right version from <a href=\"http://morfeusz.sgjp.pl/download/\">Morfeusz download page</a> do the following:</p>\n<pre class='language-javascriptreact'><code>tar xzfv &lt;path to archive&gt;\nsudo cp morfeusz/lib/libmorfeusz2.so /usr/lib/<span class=\"hljs-built_in\">local</span>\nsudo chmod a+x /usr/lib/<span class=\"hljs-built_in\">local</span>/libmorfeusz2.so\nsudo <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"/usr/local/lib\"</span> &gt; /etc/ld.so.conf.d/local.conf\nsudo ldconfig</code></pre><p>Now we can download and install the python egg from morfeusz download page. </p>\n<pre class='language-javascriptreact'><code>easy_install &lt;path_to_downloaded_egg&gt;</code></pre><p>The best thing about the python package is that you can retrieve the result from the analyzer using just a couple of python lines:</p>\n<pre class='language-javascriptreact'><code><span class=\"hljs-keyword\">import</span> morfeusz2\nm = morfeusz2.Morfeusz()\nresult = m.analyze(<span class=\"hljs-string\">\"Ala ma kota, kot ma Alę.\"</span>)\n<span class=\"hljs-comment\"># the result is:</span>\n[(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, (<span class=\"hljs-string\">'Dyrektywa'</span>, <span class=\"hljs-string\">'dyrektywa'</span>, <span class=\"hljs-string\">'subst:sg:nom:f'</span>, [<span class=\"hljs-string\">'nazwa_pospolita'</span>], [])),   \n (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, (<span class=\"hljs-string\">'PSD2'</span>, <span class=\"hljs-string\">'PSD2'</span>, <span class=\"hljs-string\">'ign'</span>, [], [])),                                         \n (<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, (<span class=\"hljs-string\">'zawiera'</span>, <span class=\"hljs-string\">'zawierać'</span>, <span class=\"hljs-string\">'fin:sg:ter:imperf'</span>, [], [])),                    \n (<span class=\"hljs-number\">3</span>,                                                                              \n  <span class=\"hljs-number\">4</span>,                                                                              \n  (<span class=\"hljs-string\">'przepisy'</span>, <span class=\"hljs-string\">'przepis'</span>, <span class=\"hljs-string\">'subst:pl:nom.acc.voc:m3'</span>, [<span class=\"hljs-string\">'nazwa_pospolita'</span>], [])),   \n (<span class=\"hljs-number\">4</span>,                                     \n  <span class=\"hljs-number\">5</span>,                                     \n  (<span class=\"hljs-string\">'odnoszące'</span>,                                                                   \n   <span class=\"hljs-string\">'odnosić'</span>,                                                                     \n   <span class=\"hljs-string\">'pact:pl:nom.acc.voc:m2.m3.f.n:imperf:aff'</span>,                                    \n   [],                                                                            \n   [])),                                 \n (<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, (<span class=\"hljs-string\">'odnoszące'</span>, <span class=\"hljs-string\">'odnosić'</span>, <span class=\"hljs-string\">'pact:sg:nom.acc.voc:n:imperf:aff'</span>, [], [])),    </code></pre><p>Putting it all in a pandas DataFrame is a trivial task as well:</p>\n<pre class='language-javascriptreact'><code><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd\ncolnames = [<span class=\"hljs-string\">\"token_start\"</span>, <span class=\"hljs-string\">\"token_end\"</span>, <span class=\"hljs-string\">\"segment\"</span>, <span class=\"hljs-string\">\"lemma\"</span>, <span class=\"hljs-string\">\"interp\"</span>, <span class=\"hljs-string\">\"common\"</span>, <span class=\"hljs-string\">\"qualifiers\"</span>]\ndf = pd.DataFrame.from_records([(elem[<span class=\"hljs-number\">0</span>], elem[<span class=\"hljs-number\">1</span>], *elem[<span class=\"hljs-number\">2</span>]) <span class=\"hljs-keyword\">for</span> elem <span class=\"hljs-keyword\">in</span> result], columns=colnames)</code></pre><p><img src=\"/images/1-assets/pandas_df.png\" alt=\"\"></p>\n<p>Helpful links on tackling Morfeusz:</p>\n<ul>\n<li><a href=\"http://download.sgjp.pl/morfeusz/Morfeusz2.pdf\">Full docs on Morfeusz</a></li>\n<li><a href=\"http://www.ipipan.waw.pl/~wolinski/publ/znakowanie.pdf\">Meaning of the morphosyntactic tags</a></li>\n</ul>\n<h3 id=\"lemmatization\">Lemmatization</h3>\n<p>You have already seen the output of a lemmatizer at the beginning of previous section. In contrast to Morfeusz&#39;s output, this time we want to obtain a mapping for each word to it&#39;s most probable dictionary form.</p>\n<p>In order to obtain direct tags instead of list of tags for each token, you will need to go deep into morphological taggers land. Your options are:</p>\n<ul>\n<li><a href=\"http://nlp.pwr.wroc.pl/redmine/projects/wcrft/wiki/\">WCRFT</a> - actually having a working demo <a href=\"http://ws.clarin-pl.eu/tager.shtml\">here</a>. Requires some skill to get it to work, dependencies are non-trivial to put together,</li>\n<li><a href=\"http://zil.ipipan.waw.pl/PANTERA\">PANTERA</a> - doesn&#39;t appear to be actively maintained</li>\n<li><a href=\"https://github.com/kawu/concraft-pl\">Concraft</a> - implemented in Haskell, looks to be the easiest one to get running</li>\n</ul>\n<p>If you are just doing a casual analysis of text, you may want to consider outsourcing the whole tagging process to a RESTful API, like <a href=\"http://nlp.pwr.wroc.pl/redmine/projects/nlprest2/wiki/Asynapi\">http://nlp.pwr.wroc.pl/redmine/projects/nlprest2/wiki/Asynapi</a>. </p>\n<p>You can easily reverse-engineer the exact calls to the API using Firefox/Chrome dev tools. This way you can find the correct values for the parameters.\n<img src=\"/images/1-assets/devtools.png\" alt=\"devtools\"></p>\n<p>As with any API provided to the public, you should notify the provider about your intentions and remember about some sane throttling of requests. Moreover, it&#39;s considered good manners to set the user parameter to something meaningful (like email address).</p>\n<h2 id=\"conclusions\">Conclusions</h2>\n<p>We went through the basic steps of analyzing a corpus and touched on more advanced topics, like morphological analysis and lemmatization. If you&#39;re doing a quick and dirty analysis, outsourcing those basic tasks to ready tools and APIs sounds like the best option. In case you need to run a large scale experiments, it makes more sense to run the tools on your own hardware.\nThe lemmatized text might become a powerful input to a more sophisticated models, like recurrent neural networks. </p>\n<h2 id=\"citations\">Citations</h2>\n<ul>\n<li>[1] <span id=\"cite-1\"></span><a href=\"http://grzegorz.jagodzinski.prv.pl/gram/pl/gram01.html\">http://grzegorz.jagodzinski.prv.pl: Polish grammar rules</a></li>\n<li>[2] <span id=\"cite-2\"></span><a href=\"https://pl.wikipedia.org/wiki/Gramatyka_j%C4%99zyka_polskiego\">Wikpedia: Polish grammar</a></li>\n<li>[3] <span id=\"cite-3\"></span><a href=\"https://www.quora.com/How-many-words-are-there-in-the-Polish-language\">Quora: how many words are the in the Polish language</a></li>\n</ul>\n","title":"Getting started with Natural Language Processing in Polish","slug":"1-getting-started-nlp","date":"2019-09-14T16:49:20.000Z","image":"1-assets/header.jpg"}
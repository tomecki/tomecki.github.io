<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <meta content="This is Tomek Dziopa's home page. Please stand clear of the closing doors." name=description> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-119904159-1"></script> <script> window.dataLayer = window.dataLayer || [];
		function gtag() { dataLayer.push(arguments); }
		gtag('js', new Date());

		gtag('config', 'UA-119904159-1'); </script> <link href=client/main.38969126.css rel=stylesheet><link href=client/[slug].4707c4c7.css rel=stylesheet><link href=client/client.9caea21e.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>You're my type: Python, meet static typing</title><noscript id=sapper-head-end></noscript> </head> <body> <div id=sapper> <nav class=svelte-x6z7kg><ul class=svelte-x6z7kg><li class=svelte-x6z7kg><a href=. class=svelte-x6z7kg>home</a></li> <li class=svelte-x6z7kg><a href=about class=svelte-x6z7kg>about</a></li> <li class=svelte-x6z7kg><a href=blog class=svelte-x6z7kg aria-current=page rel=prefetch>blog</a></ul></nav> <main class=svelte-1uhnsl8> <div class="svelte-jxhl00 header"><img alt="You're my type: Python, meet static typing" src=images/3-assets/shelby-miller-hL0xl0qmxYM-unsplash.jpg class=svelte-jxhl00 style=object-position:bottom></div> <h1>You're my type: Python, meet static typing</h1> by Tomek Dziopa <div class="svelte-jxhl00 content"><p><strong>If you’re writing Python code in a production environment, it’s quite likely that you have been using type hints or static type checking. Why do we need these tools? How can you use them when you’re developing your own project? I hope to answer these questions in this blogpost.</strong></p> <h2 id=the-why>The why</h2> <p>Python was designed as a dynamically typed language - the developer should be able to solve the problems quickly, iterating quickly in the interactive REPL. The type system will work things out transparently for the developer. </p> <pre class=language-javascriptreact><code><span class=hljs-function><span class=hljs-keyword>def</span> <span class=hljs-title>checkConstraintsList2</span><span class=hljs-params>(solution, data)</span>:</span>
    <span class=hljs-string>"""
    This is an actual excerpt from a BEng thesis, python2 style.
    Trying to infer the data types is painful, so is debugging or
    extending this snippet.
    :param solution:
    :param data:
    """</span>
    <span class=hljs-keyword>for</span> slot <span class=hljs-keyword>in</span> range(<span class=hljs-number>0</span>, data.periodsPerDay * data.daysNum):
        <span class=hljs-keyword>for</span> lecture <span class=hljs-keyword>in</span> solution[slot]:
            <span class=hljs-keyword>for</span> constraint <span class=hljs-keyword>in</span> data.getConstraintsForCourse(lecture[<span class=hljs-number>0</span>]):
                <span class=hljs-keyword>if</span> slot == solution.mapKeys(constraint):
                    <span class=hljs-keyword>print</span> <span class=hljs-string>"Violation lecture"</span>, lecture, <span class=hljs-string>"slot"</span>, slot</code></pre><p class=caption>Ugly Python2-style snippet from an ML project. Non-trivial data-structures make reading this a horrible experience.</p> <p>This approach works great for tiny, non-critical codebases, with a limited number of developers. Since even Google was at some point in time a tiny, non-critical codebase I’d advise you not to follow this path.</p> <h2 id=the-how>The how</h2> <p><a href=https://www.python.org/dev/peps/pep-0484/#type-comments>PEP484</a> added type comments as a standardized way of adding type information to Python code.</p> <pre class=language-javascriptreact><code><span class=hljs-function><span class=hljs-keyword>def</span> <span class=hljs-title>weather</span><span class=hljs-params>(celsius)</span>:</span> <span class=hljs-comment># type: (Optional[float]) -> Union[str, Dict[str, str]]</span>
    <span class=hljs-keyword>if</span> celsius <span class=hljs-keyword>is</span> <span class=hljs-literal>None</span>:
        <span class=hljs-keyword>return</span> <span class=hljs-string>"I don’t know what to say"</span>
    <span class=hljs-keyword>return</span> (
        <span class=hljs-string>"It’s rather warm"</span>
        <span class=hljs-keyword>if</span> celsius > <span class=hljs-number>20</span> <span class=hljs-keyword>else</span> {<span class=hljs-string>"opinion"</span>: <span class=hljs-string>"Bring back summer :/"</span>}
    )</code></pre><p class=caption>The separation of the identifier and type hint makes it hard to read.</p> <p>This used to be the only way to add types to Python codebase until Python 3.6 got released, <a href=https://www.python.org/dev/peps/pep-0484/#id14>adding optional type hints</a> to it’s grammar:</p> <pre class=language-javascriptreact><code><span class=hljs-keyword>from</span> typing <span class=hljs-keyword>import</span> Dict, Optional, Union

<span class=hljs-function><span class=hljs-keyword>def</span> <span class=hljs-title>weather</span><span class=hljs-params>(celsius: Optional[float])</span> -> Union[str, Dict[str, str]]:</span>
    <span class=hljs-keyword>if</span> celsius <span class=hljs-keyword>is</span> <span class=hljs-literal>None</span>:
        <span class=hljs-keyword>return</span> <span class=hljs-string>"I don’t know what to say"</span>
    <span class=hljs-keyword>return</span> (
        <span class=hljs-string>"It’s rather warm"</span>
        <span class=hljs-keyword>if</span> celsius > <span class=hljs-number>21</span> <span class=hljs-keyword>else</span> {<span class=hljs-string>"opinion"</span>: <span class=hljs-string>"Bring back summer :/"</span>}
    )</code></pre><p class=caption>Much better.</p> <p>Much better. Please note - this code example introduced some additional import statements. These are not free, since Python interpreter needs to load code for that import, resulting in some barely noticeable overhead, depending on your codebase. </p> <p>If you’re looking to speed up your code, Cython uses a <a href=https://cython.readthedocs.io/en/latest/src/quickstart/cythonize.html#typing-variables>slightly altered Python syntax</a> of type annotations for compiling to machine code in for the sake of the speed.</p> <h2 id=the-wow>The wow</h2> <p>The type hints might be helpful for the developer, but humans commit errors all the time - you should definitely use a type checker to validate if your assumptions are correct. (And, catch some bugs before they hit you!)</p> <h2 id=how-do-you-introduce-types-in-your-codebase>How do you introduce types in your codebase?</h2> <p>Most type checkers follow the approach of gradual introduction of enforcement of type correctness. The type checkers can infer the types of the variables or return types to some degree, but in this approach it’s the developers responsibility to gradually increase the coverage of strict type checking, usually module by module.</p> <p>Additionally, you can control either particular features of the type system being enforced (e.g. forbidding redefinition of a variable with a different type) or select one of the predefined strictness levels. The main issue is that it involves manual process - you need to define the order or modules in which you want to annotate your codebase and, well, manually do it.</p> <p>Pytype follows a completely different approach - it type checks the entire codebase by default, instead taking a very permissive take on type correctness - if it’s valid Python, it’s OK. This approach definitely makes sense in application to older or unmaintained projects with minimal or no type hints since it allows you to catch the basic type errors very quickly, with no changes made to the codebase. This sounds very tempting, but the long term solution should be to apply more strict type checking. Valid Python’s type system is just way too permissive.</p> <h2 id=most-popular-python-type-checkers-compared>Most popular Python type checkers, compared</h2> <table> <thead> <tr> <th align=center></th> <th><a href=http://mypy-lang.org/ ><strong>Mypy</strong></a></th> <th><a href=https://github.com/google/pytype>pytype</a></th> <th><a href=https://github.com/microsoft/pyright>Pyright</a></th> <th><a href=https://github.com/facebook/pyre-check>Pyre</a></th> </tr> </thead> <tr> <td align=center>Modes</td> <td><a href=https://mypy.readthedocs.io/en/stable/command_line.html#miscellaneous-strictness-flags>Feature flags for strictness checks</a></td> <td>Lenient: if it runs, it’s valid</td> <td>Multiple levels of strictness enforced per project and directory</td> <td>Permissive / strict modes</td> </tr> <tr> <td align=center>Applying to existing code</td> <td>Gradual</td> <td>Runs on entire codebase, type hints completely optional</td> <td>Gradual</td> <td>Gradual</td> </tr> <tr> <td align=center>Implementation</td> <td>Daemon mode, incremental updates</td> <td>set of CLI tools</td> <td>Typescript, daemon mode, incremental updates</td> <td>Daemon mode with watchman, incremental updates</td> </tr> <tr> <td align=center>IDE integration</td> <td><a href=https://github.com/tomv564/pyls-mypy>Incomplete LSP plugin</a></td> <td><a href=https://github.com/google/pytype/issues/326>maybe someday</a></td> <td>LSP, <a href=https://devblogs.microsoft.com/python/announcing-pylance-fast-feature-rich-language-support-for-python-in-visual-studio-code/ >Pylance vscode extension</a>, vim</td> <td>VSCode, vim, emacs</td> </tr> <tr> <td align=center>Extra points</td> <td><a href=http://mypy-lang.org/about.html>Guido-approved</a></td> <td><a href=https://github.com/google/pytype/tree/master/pytype/tools/merge_pyi>Merge-pyi</a> automatically merges type stubs into your codebase</td> <td>Snappy vscode integration, no Python required - runs on node js</td> <td>Built in Pysa - static security analysis tool</td> </tr> </table> <h2 id=third-party-libraries>Third-party libraries</h2> <p>Not all libraries you use are type annotated - that’s a sad fact. There are two solutions to this problem - either just annotate them, or use type stubs. If you’re using a library, you care only about the exported data structures and function signature types. Some typecheckers utilize an official collection of type annotations maintained as a part of Python project - <a href=https://github.com/python/typeshed>Typeshed</a> (see <a href=https://github.com/python/typeshed/blob/master/third_party/3/pytest_mock/plugin.pyi>example type stubs file</a>). If you find a project that doesn’t have type hints, you can contribute your annotations to that repo, for the benefit of everyone!</p> <pre class=language-javascriptreact><code><span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>TcpWSGIServer</span><span class=hljs-params>(BaseWSGIServer)</span>:</span>
    <span class=hljs-function><span class=hljs-keyword>def</span> <span class=hljs-title>bind_server_socket</span><span class=hljs-params>(self)</span> -> <span class=hljs-keyword>None</span>:</span> ...
    <span class=hljs-function><span class=hljs-keyword>def</span> <span class=hljs-title>getsockname</span><span class=hljs-params>(self)</span> -> Tuple[str, Tuple[str, int]]:</span> ...
    <span class=hljs-function><span class=hljs-keyword>def</span> <span class=hljs-title>set_socket_options</span><span class=hljs-params>(self, conn: SocketType)</span> -> <span class=hljs-keyword>None</span>:</span> ...</code></pre><p class=caption>The ... is an Ellipsis object. Since it's builtin constant, the code above is valid Python, albeit useless (besides being type stub).</p> <p>Some static type checkers create pyi stubs behind the scenes. Pytype allows you to combine the inferred type stubs with the code using a single command. This is really neat - you can seed the initial types in your code with a single command - although the quality of the annotations is quite weak, since Pytype is a lenient tool, you will see <code>Any</code> wildcard type a lot.</p> <h2 id=type-hints-beyond-static-type-checking>Type hints: beyond static type checking</h2> <p>The type-correctness is not the only use case of the type hints. Here you can find some neat projects making good use of type annotations:</p> <h3 id=pydantic><a href=https://github.com/samuelcolvin/pydantic>Pydantic</a></h3> <p>This library allows you to specify and validate your data model using intuitive type-annotated classes. It’s super fast and is a foundation of FastAPI web framework (request/response models and validations).</p> <pre class=language-javascriptreact><code><span class=hljs-keyword>from</span> typing <span class=hljs-keyword>import</span> List, Optional

<span class=hljs-keyword>from</span> fastapi <span class=hljs-keyword>import</span> FastAPI
<span class=hljs-keyword>from</span> pydantic <span class=hljs-keyword>import</span> BaseModel

app = FastAPI()


<span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Item</span><span class=hljs-params>(BaseModel)</span>:</span>
    name: str
    tax: Optional[float] = <span class=hljs-literal>None</span>
    tags: List[str] = []


<span class=hljs-meta>@app.post("/items/", response_model=Item)</span>
<span class=hljs-keyword>async</span> <span class=hljs-function><span class=hljs-keyword>def</span> <span class=hljs-title>create_item</span><span class=hljs-params>(item: Item)</span>:</span>
    <span class=hljs-keyword>return</span> item</code></pre><p class=caption>You get request and response validation for free.</p> <h3 id=typer><a href=https://github.com/tiangolo/typer>Typer</a></h3> <p>Generating CLIs using just type-annotated functions. Takes care of parsing, validating and generating boilerplate for you. </p> <h3 id=hypothesis><a href=https://hypothesis.readthedocs.io/en/latest/quickstart.html>Hypothesis</a></h3> <p>Hypothesis is a library enabling property-based testing for pytest. Instead of crafting custom unit test examples, you specify functions generating the test cases for you. Or… you can use inferred strategies which will sample the space of all valid values for a given type!</p> <pre class=language-javascriptreact><code><span class=hljs-keyword>from</span> hypothesis <span class=hljs-keyword>import</span> given, infer

<span class=hljs-meta>@given(username=infer, article_id=infer, comment=infer)</span>
<span class=hljs-function><span class=hljs-keyword>def</span> <span class=hljs-title>test_adding_comment</span><span class=hljs-params>(username: str, article_id: int, comment: str)</span>:</span>
    <span class=hljs-keyword>with</span> mock_article(article_id):
    comment_id = add_comment(username, comment)
    <span class=hljs-keyword>assert</span> comment_id <span class=hljs-keyword>is</span> <span class=hljs-keyword>not</span> <span class=hljs-literal>None</span></code></pre><p class=caption>Inferred strategies are a good start, but you should limit the search space of your examples to match your assumptions (would you expect your article_ids to be negative?)</p> <h2 id=outro>Outro</h2> <p>Static type checking gives the developers additional layer of validation of their code against the common type errors. With the wonders of static analysis, you can significantly reduce the number of bugs, make contributing to the code easier and catch some non-trivial security issues. </p> <p><img alt=Thanks src=https://media.giphy.com/media/l4pTjOu0NsrLApt0Q/giphy-downsized.gif></p> </div></main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{html:"\u003Cp\u003E\u003Cstrong\u003EIf you’re writing Python code in a production environment, it’s quite likely that you have been using type hints or static type checking. Why do we need these tools? How can you use them when you’re developing your own project? I hope to answer these questions in this blogpost.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Ch2 id=\"the-why\"\u003EThe why\u003C\u002Fh2\u003E\n\u003Cp\u003EPython was designed as a dynamically typed language - the developer should be able to solve the problems quickly, iterating quickly in the interactive REPL. The type system will work things out transparently for the developer. \u003C\u002Fp\u003E\n\u003Cpre class='language-javascriptreact'\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EcheckConstraintsList2\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(solution, data)\u003C\u002Fspan\u003E:\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-string\"\u003E\"\"\"\n    This is an actual excerpt from a BEng thesis, python2 style.\n    Trying to infer the data types is painful, so is debugging or\n    extending this snippet.\n    :param solution:\n    :param data:\n    \"\"\"\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E slot \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E range(\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E, data.periodsPerDay * data.daysNum):\n        \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E lecture \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E solution[slot]:\n            \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E constraint \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E data.getConstraintsForCourse(lecture[\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E]):\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E slot == solution.mapKeys(constraint):\n                    \u003Cspan class=\"hljs-keyword\"\u003Eprint\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E\"Violation lecture\"\u003C\u002Fspan\u003E, lecture, \u003Cspan class=\"hljs-string\"\u003E\"slot\"\u003C\u002Fspan\u003E, slot\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp class=\"caption\"\u003EUgly Python2-style snippet from an ML project. Non-trivial data-structures make reading this a horrible experience.\u003C\u002Fp\u003E\n\n\u003Cp\u003EThis approach works great for tiny, non-critical codebases, with a limited number of developers. Since even Google was at some point in time a tiny, non-critical codebase I’d advise you not to follow this path.\u003C\u002Fp\u003E\n\u003Ch2 id=\"the-how\"\u003EThe how\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fwww.python.org\u002Fdev\u002Fpeps\u002Fpep-0484\u002F#type-comments\"\u003EPEP484\u003C\u002Fa\u003E added type comments as a standardized way of adding type information to Python code.\u003C\u002Fp\u003E\n\u003Cpre class='language-javascriptreact'\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eweather\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(celsius)\u003C\u002Fspan\u003E:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-comment\"\u003E# type: (Optional[float]) -&gt; Union[str, Dict[str, str]]\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E celsius \u003Cspan class=\"hljs-keyword\"\u003Eis\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ENone\u003C\u002Fspan\u003E:\n        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E\"I don’t know what to say\"\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E (\n        \u003Cspan class=\"hljs-string\"\u003E\"It’s rather warm\"\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E celsius &gt; \u003Cspan class=\"hljs-number\"\u003E20\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\u003Cspan class=\"hljs-string\"\u003E\"opinion\"\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E\"Bring back summer :\u002F\"\u003C\u002Fspan\u003E}\n    )\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp class=\"caption\"\u003EThe separation of the identifier and type hint makes it hard to read.\u003C\u002Fp\u003E\n\n\u003Cp\u003EThis used to be the only way to add types to Python codebase until Python 3.6 got released, \u003Ca href=\"https:\u002F\u002Fwww.python.org\u002Fdev\u002Fpeps\u002Fpep-0484\u002F#id14\"\u003Eadding optional type hints\u003C\u002Fa\u003E to it’s grammar:\u003C\u002Fp\u003E\n\u003Cpre class='language-javascriptreact'\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E typing \u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E Dict, Optional, Union\n\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eweather\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(celsius: Optional[float])\u003C\u002Fspan\u003E -&gt; Union[str, Dict[str, str]]:\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E celsius \u003Cspan class=\"hljs-keyword\"\u003Eis\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ENone\u003C\u002Fspan\u003E:\n        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E\"I don’t know what to say\"\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E (\n        \u003Cspan class=\"hljs-string\"\u003E\"It’s rather warm\"\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E celsius &gt; \u003Cspan class=\"hljs-number\"\u003E21\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\u003Cspan class=\"hljs-string\"\u003E\"opinion\"\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E\"Bring back summer :\u002F\"\u003C\u002Fspan\u003E}\n    )\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp class=\"caption\"\u003EMuch better.\u003C\u002Fp\u003E\n\n\u003Cp\u003EMuch better. Please note - this code example introduced some additional import statements. These are not free, since Python interpreter needs to load code for that import, resulting in some barely noticeable overhead, depending on your codebase. \u003C\u002Fp\u003E\n\u003Cp\u003EIf you’re looking to speed up your code, Cython uses a \u003Ca href=\"https:\u002F\u002Fcython.readthedocs.io\u002Fen\u002Flatest\u002Fsrc\u002Fquickstart\u002Fcythonize.html#typing-variables\"\u003Eslightly altered Python syntax\u003C\u002Fa\u003E of type annotations for compiling to machine code in for the sake of the speed.\u003C\u002Fp\u003E\n\u003Ch2 id=\"the-wow\"\u003EThe wow\u003C\u002Fh2\u003E\n\u003Cp\u003EThe type hints might be helpful for the developer, but humans commit errors all the time - you should definitely use a type checker to validate if your assumptions are correct. (And, catch some bugs before they hit you!)\u003C\u002Fp\u003E\n\u003Ch2 id=\"how-do-you-introduce-types-in-your-codebase\"\u003EHow do you introduce types in your codebase?\u003C\u002Fh2\u003E\n\u003Cp\u003EMost type checkers follow the approach of gradual introduction of enforcement of type correctness. The type checkers can infer the types of the variables or return types to some degree, but in this approach it’s the developers responsibility to gradually increase the coverage of strict type checking, usually module by module.\u003C\u002Fp\u003E\n\u003Cp\u003EAdditionally, you can control either particular features of the type system being enforced (e.g. forbidding redefinition of a variable with a different type) or select one of the predefined strictness levels. \nThe main issue is that it involves manual process - you need to define the order or modules in which you want to annotate your codebase and, well, manually do it.\u003C\u002Fp\u003E\n\u003Cp\u003EPytype follows a completely different approach - it type checks the entire codebase by default, instead taking a very permissive take on type correctness - if it’s valid Python, it’s OK. \nThis approach definitely makes sense in application to older or unmaintained projects with minimal or no type hints since it allows you to catch the basic type errors very quickly, with no changes made to the codebase. This sounds very tempting, but the long term solution should be to apply more strict type checking. Valid Python’s type system is just way too permissive.\u003C\u002Fp\u003E\n\u003Ch2 id=\"most-popular-python-type-checkers-compared\"\u003EMost popular Python type checkers, compared\u003C\u002Fh2\u003E\n\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth align=\"center\"\u003E\u003C\u002Fth\u003E\n\u003Cth\u003E\u003Ca href=\"http:\u002F\u002Fmypy-lang.org\u002F\"\u003E\u003Cstrong\u003EMypy\u003C\u002Fstrong\u003E\u003C\u002Fa\u003E\u003C\u002Fth\u003E\n\u003Cth\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fgoogle\u002Fpytype\"\u003Epytype\u003C\u002Fa\u003E\u003C\u002Fth\u003E\n\u003Cth\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fmicrosoft\u002Fpyright\"\u003EPyright\u003C\u002Fa\u003E\u003C\u002Fth\u003E\n\u003Cth\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ffacebook\u002Fpyre-check\"\u003EPyre\u003C\u002Fa\u003E\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\n\u003Ctd align=\"center\"\u003EModes\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003Ca href=\"https:\u002F\u002Fmypy.readthedocs.io\u002Fen\u002Fstable\u002Fcommand_line.html#miscellaneous-strictness-flags\"\u003EFeature flags for strictness checks\u003C\u002Fa\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003ELenient: if it runs, it’s valid\u003C\u002Ftd\u003E\n\u003Ctd\u003EMultiple levels of strictness enforced per project and directory\u003C\u002Ftd\u003E\n\u003Ctd\u003EPermissive \u002F strict modes\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd align=\"center\"\u003EApplying to existing code\u003C\u002Ftd\u003E\n\u003Ctd\u003EGradual\u003C\u002Ftd\u003E\n\u003Ctd\u003ERuns on entire codebase, type hints completely optional\u003C\u002Ftd\u003E\n\u003Ctd\u003EGradual\u003C\u002Ftd\u003E\n\u003Ctd\u003EGradual\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd align=\"center\"\u003EImplementation\u003C\u002Ftd\u003E\n\u003Ctd\u003EDaemon mode, incremental updates\u003C\u002Ftd\u003E\n\u003Ctd\u003Eset of CLI tools\u003C\u002Ftd\u003E\n\u003Ctd\u003ETypescript, daemon mode, incremental updates\u003C\u002Ftd\u003E\n\u003Ctd\u003EDaemon mode with watchman, incremental updates\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd align=\"center\"\u003EIDE integration\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ftomv564\u002Fpyls-mypy\"\u003EIncomplete LSP plugin\u003C\u002Fa\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fgoogle\u002Fpytype\u002Fissues\u002F326\"\u003Emaybe someday\u003C\u002Fa\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003ELSP, \u003Ca href=\"https:\u002F\u002Fdevblogs.microsoft.com\u002Fpython\u002Fannouncing-pylance-fast-feature-rich-language-support-for-python-in-visual-studio-code\u002F\"\u003EPylance vscode extension\u003C\u002Fa\u003E, vim\u003C\u002Ftd\u003E\n\u003Ctd\u003EVSCode, vim, emacs\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd align=\"center\"\u003EExtra points\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003Ca href=\"http:\u002F\u002Fmypy-lang.org\u002Fabout.html\"\u003EGuido-approved\u003C\u002Fa\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fgoogle\u002Fpytype\u002Ftree\u002Fmaster\u002Fpytype\u002Ftools\u002Fmerge_pyi\"\u003EMerge-pyi\u003C\u002Fa\u003E automatically merges type stubs into your codebase\u003C\u002Ftd\u003E\n\u003Ctd\u003ESnappy vscode integration, no Python required - runs on node js\u003C\u002Ftd\u003E\n\u003Ctd\u003EBuilt in Pysa - static security analysis tool\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\n\u003Ch2 id=\"third-party-libraries\"\u003EThird-party libraries\u003C\u002Fh2\u003E\n\u003Cp\u003ENot all libraries you use are type annotated - that’s a sad fact. There are two solutions to this problem - either just annotate them, or use type stubs. If you’re using a library, you care only about the exported data structures and function signature types.\nSome typecheckers utilize an official collection of type annotations maintained as a part of Python project - \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fpython\u002Ftypeshed\"\u003ETypeshed\u003C\u002Fa\u003E (see \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fpython\u002Ftypeshed\u002Fblob\u002Fmaster\u002Fthird_party\u002F3\u002Fpytest_mock\u002Fplugin.pyi\"\u003Eexample type stubs file\u003C\u002Fa\u003E). If you find a project that doesn’t have type hints, you can contribute your annotations to that repo, for the benefit of everyone!\u003C\u002Fp\u003E\n\u003Cpre class='language-javascriptreact'\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003ETcpWSGIServer\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(BaseWSGIServer)\u003C\u002Fspan\u003E:\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ebind_server_socket\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(self)\u003C\u002Fspan\u003E -&gt; \u003Cspan class=\"hljs-keyword\"\u003ENone\u003C\u002Fspan\u003E:\u003C\u002Fspan\u003E ...\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Egetsockname\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(self)\u003C\u002Fspan\u003E -&gt; Tuple[str, Tuple[str, int]]:\u003C\u002Fspan\u003E ...\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eset_socket_options\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(self, conn: SocketType)\u003C\u002Fspan\u003E -&gt; \u003Cspan class=\"hljs-keyword\"\u003ENone\u003C\u002Fspan\u003E:\u003C\u002Fspan\u003E ...\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp class=\"caption\"\u003EThe ... is an Ellipsis object. Since it's builtin constant, the code above is valid Python, albeit useless (besides being type stub).\u003C\u002Fp\u003E\n\n\n\u003Cp\u003ESome static type checkers create pyi stubs behind the scenes. Pytype allows you to combine the inferred type stubs with the code using a single command. This is really neat - you can seed the initial types in your code with a single command - although the quality of the annotations is quite weak, since Pytype is a lenient tool, you will see \u003Ccode\u003EAny\u003C\u002Fcode\u003E wildcard type a lot.\u003C\u002Fp\u003E\n\u003Ch2 id=\"type-hints-beyond-static-type-checking\"\u003EType hints: beyond static type checking\u003C\u002Fh2\u003E\n\u003Cp\u003EThe type-correctness is not the only use case of the type hints. Here you can find some neat projects making good use of type annotations:\u003C\u002Fp\u003E\n\u003Ch3 id=\"pydantic\"\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fsamuelcolvin\u002Fpydantic\"\u003EPydantic\u003C\u002Fa\u003E\u003C\u002Fh3\u003E\n\u003Cp\u003EThis library allows you to specify and validate your data model using intuitive type-annotated classes. It’s super fast and is a foundation of FastAPI web framework (request\u002Fresponse models and \nvalidations).\u003C\u002Fp\u003E\n\u003Cpre class='language-javascriptreact'\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E typing \u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E List, Optional\n\n\u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E fastapi \u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E FastAPI\n\u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E pydantic \u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E BaseModel\n\napp = FastAPI()\n\n\n\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EItem\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(BaseModel)\u003C\u002Fspan\u003E:\u003C\u002Fspan\u003E\n    name: str\n    tax: Optional[float] = \u003Cspan class=\"hljs-literal\"\u003ENone\u003C\u002Fspan\u003E\n    tags: List[str] = []\n\n\n\u003Cspan class=\"hljs-meta\"\u003E@app.post(\"\u002Fitems\u002F\", response_model=Item)\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Easync\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ecreate_item\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(item: Item)\u003C\u002Fspan\u003E:\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E item\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp class=\"caption\"\u003EYou get request and response validation for free.\u003C\u002Fp\u003E\n\n\u003Ch3 id=\"typer\"\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ftiangolo\u002Ftyper\"\u003ETyper\u003C\u002Fa\u003E\u003C\u002Fh3\u003E\n\u003Cp\u003EGenerating CLIs using just type-annotated functions. Takes care of parsing, validating and generating boilerplate for you. \u003C\u002Fp\u003E\n\u003Ch3 id=\"hypothesis\"\u003E\u003Ca href=\"https:\u002F\u002Fhypothesis.readthedocs.io\u002Fen\u002Flatest\u002Fquickstart.html\"\u003EHypothesis\u003C\u002Fa\u003E\u003C\u002Fh3\u003E\n\u003Cp\u003EHypothesis is a library enabling property-based testing for pytest. Instead of crafting custom unit test examples, you specify functions generating the test cases for you. Or… you can use inferred strategies which will sample the space of all valid values for a given type!\u003C\u002Fp\u003E\n\u003Cpre class='language-javascriptreact'\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E hypothesis \u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E given, infer\n\n\u003Cspan class=\"hljs-meta\"\u003E@given(username=infer, article_id=infer, comment=infer)\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Etest_adding_comment\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(username: str, article_id: int, comment: str)\u003C\u002Fspan\u003E:\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ewith\u003C\u002Fspan\u003E mock_article(article_id):\n    comment_id = add_comment(username, comment)\n    \u003Cspan class=\"hljs-keyword\"\u003Eassert\u003C\u002Fspan\u003E comment_id \u003Cspan class=\"hljs-keyword\"\u003Eis\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Enot\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ENone\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp class=\"caption\"\u003EInferred strategies are a good start, but you should limit the search space of your examples to match your assumptions (would you expect your article_ids to be negative?)\u003C\u002Fp\u003E\n\n\u003Ch2 id=\"outro\"\u003EOutro\u003C\u002Fh2\u003E\n\u003Cp\u003EStatic type checking gives the developers additional layer of validation of their code against the common type errors. With the wonders of static analysis, you can significantly reduce the number of bugs, make contributing to the code easier and catch some non-trivial security issues. \u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fmedia.giphy.com\u002Fmedia\u002Fl4pTjOu0NsrLApt0Q\u002Fgiphy-downsized.gif\" alt=\"Thanks\"\u003E\u003C\u002Fp\u003E\n",title:"You're my type: Python, meet static typing",tags:["blog","post"],date:"2020-09-06T16:49:20.000Z",slug:"3-youre-my-type",image:"3-assets\u002Fshelby-miller-hL0xl0qmxYM-unsplash.jpg",author:"Tomek Dziopa",header_align:"bottom"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');var s=document.createElement("script");try{new Function("if(0)import('')")();s.src="/client/client.9caea21e.js";s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main","/client/client.9caea21e.js")}document.head.appendChild(s)</script> 
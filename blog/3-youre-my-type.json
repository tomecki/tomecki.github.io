{"html":"<p><strong>If you’re writing Python code in a production environment, it’s quite likely that you have been using type hints or static type checking. Why do we need these tools? How can you use them when you’re developing your own project? I hope to answer these questions in this blogpost.</strong></p>\n<h2 id=\"the-why\">The why</h2>\n<p>Python was designed as a dynamically typed language - the developer should be able to solve the problems quickly, iterating quickly in the interactive REPL. The type system will work things out transparently for the developer. </p>\n<pre class='language-javascriptreact'><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">checkConstraintsList2</span><span class=\"hljs-params\">(solution, data)</span>:</span>\n    <span class=\"hljs-string\">\"\"\"\n    This is an actual excerpt from a BEng thesis, python2 style.\n    Trying to infer the data types is painful, so is debugging or\n    extending this snippet.\n    :param solution:\n    :param data:\n    \"\"\"</span>\n    <span class=\"hljs-keyword\">for</span> slot <span class=\"hljs-keyword\">in</span> range(<span class=\"hljs-number\">0</span>, data.periodsPerDay * data.daysNum):\n        <span class=\"hljs-keyword\">for</span> lecture <span class=\"hljs-keyword\">in</span> solution[slot]:\n            <span class=\"hljs-keyword\">for</span> constraint <span class=\"hljs-keyword\">in</span> data.getConstraintsForCourse(lecture[<span class=\"hljs-number\">0</span>]):\n                <span class=\"hljs-keyword\">if</span> slot == solution.mapKeys(constraint):\n                    <span class=\"hljs-keyword\">print</span> <span class=\"hljs-string\">\"Violation lecture\"</span>, lecture, <span class=\"hljs-string\">\"slot\"</span>, slot</code></pre><p class=\"caption\">Ugly Python2-style snippet from an ML project. Non-trivial data-structures make reading this a horrible experience.</p>\n\n<p>This approach works great for tiny, non-critical codebases, with a limited number of developers. Since even Google was at some point in time a tiny, non-critical codebase I’d advise you not to follow this path.</p>\n<h2 id=\"the-how\">The how</h2>\n<p><a href=\"https://www.python.org/dev/peps/pep-0484/#type-comments\">PEP484</a> added type comments as a standardized way of adding type information to Python code.</p>\n<pre class='language-javascriptreact'><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">weather</span><span class=\"hljs-params\">(celsius)</span>:</span> <span class=\"hljs-comment\"># type: (Optional[float]) -&gt; Union[str, Dict[str, str]]</span>\n    <span class=\"hljs-keyword\">if</span> celsius <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"I don’t know what to say\"</span>\n    <span class=\"hljs-keyword\">return</span> (\n        <span class=\"hljs-string\">\"It’s rather warm\"</span>\n        <span class=\"hljs-keyword\">if</span> celsius &gt; <span class=\"hljs-number\">20</span> <span class=\"hljs-keyword\">else</span> {<span class=\"hljs-string\">\"opinion\"</span>: <span class=\"hljs-string\">\"Bring back summer :/\"</span>}\n    )</code></pre><p class=\"caption\">The separation of the identifier and type hint makes it hard to read.</p>\n\n<p>This used to be the only way to add types to Python codebase until Python 3.6 got released, <a href=\"https://www.python.org/dev/peps/pep-0484/#id14\">adding optional type hints</a> to it’s grammar:</p>\n<pre class='language-javascriptreact'><code><span class=\"hljs-keyword\">from</span> typing <span class=\"hljs-keyword\">import</span> Dict, Optional, Union\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">weather</span><span class=\"hljs-params\">(celsius: Optional[float])</span> -&gt; Union[str, Dict[str, str]]:</span>\n    <span class=\"hljs-keyword\">if</span> celsius <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"I don’t know what to say\"</span>\n    <span class=\"hljs-keyword\">return</span> (\n        <span class=\"hljs-string\">\"It’s rather warm\"</span>\n        <span class=\"hljs-keyword\">if</span> celsius &gt; <span class=\"hljs-number\">21</span> <span class=\"hljs-keyword\">else</span> {<span class=\"hljs-string\">\"opinion\"</span>: <span class=\"hljs-string\">\"Bring back summer :/\"</span>}\n    )</code></pre><p class=\"caption\">Much better.</p>\n\n<p>Much better. Please note - this code example introduced some additional import statements. These are not free, since Python interpreter needs to load code for that import, resulting in some barely noticeable overhead, depending on your codebase. </p>\n<p>If you’re looking to speed up your code, Cython uses a <a href=\"https://cython.readthedocs.io/en/latest/src/quickstart/cythonize.html#typing-variables\">slightly altered Python syntax</a> of type annotations for compiling to machine code in for the sake of the speed.</p>\n<h2 id=\"the-wow\">The wow</h2>\n<p>The type hints might be helpful for the developer, but humans commit errors all the time - you should definitely use a type checker to validate if your assumptions are correct. (And, catch some bugs before they hit you!)</p>\n<h2 id=\"how-do-you-introduce-types-in-your-codebase\">How do you introduce types in your codebase?</h2>\n<p>Most type checkers follow the approach of gradual introduction of enforcement of type correctness. The type checkers can infer the types of the variables or return types to some degree, but in this approach it’s the developers responsibility to gradually increase the coverage of strict type checking, usually module by module.</p>\n<p>Additionally, you can control either particular features of the type system being enforced (e.g. forbidding redefinition of a variable with a different type) or select one of the predefined strictness levels. \nThe main issue is that it involves manual process - you need to define the order or modules in which you want to annotate your codebase and, well, manually do it.</p>\n<p>Pytype follows a completely different approach - it type checks the entire codebase by default, instead taking a very permissive take on type correctness - if it’s valid Python, it’s OK. \nThis approach definitely makes sense in application to older or unmaintained projects with minimal or no type hints since it allows you to catch the basic type errors very quickly, with no changes made to the codebase. This sounds very tempting, but the long term solution should be to apply more strict type checking. Valid Python’s type system is just way too permissive.</p>\n<h2 id=\"most-popular-python-type-checkers-compared\">Most popular Python type checkers, compared</h2>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th><a href=\"http://mypy-lang.org/\"><strong>Mypy</strong></a></th>\n<th><a href=\"https://github.com/google/pytype\">pytype</a></th>\n<th><a href=\"https://github.com/microsoft/pyright\">Pyright</a></th>\n<th><a href=\"https://github.com/facebook/pyre-check\">Pyre</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Modes</td>\n<td><a href=\"https://mypy.readthedocs.io/en/stable/command_line.html#miscellaneous-strictness-flags\">Feature flags for strictness checks</a></td>\n<td>Lenient: if it runs, it’s valid</td>\n<td>Multiple levels of strictness enforced per project and directory</td>\n<td>Permissive / strict modes</td>\n</tr>\n<tr>\n<td align=\"center\">Applying to existing code</td>\n<td>Gradual</td>\n<td>Runs on entire codebase, type hints completely optional</td>\n<td>Gradual</td>\n<td>Gradual</td>\n</tr>\n<tr>\n<td align=\"center\">Implementation</td>\n<td>Daemon mode, incremental updates</td>\n<td>set of CLI tools</td>\n<td>Typescript, daemon mode, incremental updates</td>\n<td>Daemon mode with watchman, incremental updates</td>\n</tr>\n<tr>\n<td align=\"center\">IDE integration</td>\n<td><a href=\"https://github.com/tomv564/pyls-mypy\">Incomplete LSP plugin</a></td>\n<td><a href=\"https://github.com/google/pytype/issues/326\">maybe someday</a></td>\n<td>LSP, <a href=\"https://devblogs.microsoft.com/python/announcing-pylance-fast-feature-rich-language-support-for-python-in-visual-studio-code/\">Pylance vscode extension</a>, vim</td>\n<td>VSCode, vim, emacs</td>\n</tr>\n<tr>\n<td align=\"center\">Extra points</td>\n<td><a href=\"http://mypy-lang.org/about.html\">Guido-approved</a></td>\n<td><a href=\"https://github.com/google/pytype/tree/master/pytype/tools/merge_pyi\">Merge-pyi</a> automatically merges type stubs into your codebase</td>\n<td>Snappy vscode integration, no Python required - runs on node js</td>\n<td>Built in Pysa - static security analysis tool</td>\n</tr>\n</tbody></table>\n<h2 id=\"third-party-libraries\">Third-party libraries</h2>\n<p>Not all libraries you use are type annotated - that’s a sad fact. There are two solutions to this problem - either just annotate them, or use type stubs. If you’re using a library, you care only about the exported data structures and function signature types.\nSome typecheckers utilize an official collection of type annotations maintained as a part of Python project - <a href=\"https://github.com/python/typeshed\">Typeshed</a> (see <a href=\"https://github.com/python/typeshed/blob/master/third_party/3/pytest_mock/plugin.pyi\">example type stubs file</a>). If you find a project that doesn’t have type hints, you can contribute your annotations to that repo, for the benefit of everyone!</p>\n<pre class='language-javascriptreact'><code><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TcpWSGIServer</span><span class=\"hljs-params\">(BaseWSGIServer)</span>:</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">bind_server_socket</span><span class=\"hljs-params\">(self)</span> -&gt; <span class=\"hljs-keyword\">None</span>:</span> ...\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">getsockname</span><span class=\"hljs-params\">(self)</span> -&gt; Tuple[str, Tuple[str, int]]:</span> ...\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">set_socket_options</span><span class=\"hljs-params\">(self, conn: SocketType)</span> -&gt; <span class=\"hljs-keyword\">None</span>:</span> ...</code></pre><p class=\"caption\">The ... is an Ellipsis object. Since it's builtin constant, the code above is valid Python, albeit useless (besides being type stub).</p>\n\n\n<p>Some static type checkers create pyi stubs behind the scenes. Pytype allows you to combine the inferred type stubs with the code using a single command. This is really neat - you can seed the initial types in your code with a single command - although the quality of the annotations is quite weak, since Pytype is a lenient tool, you will see <code>Any</code> wildcard type a lot.</p>\n<h2 id=\"type-hints-beyond-static-type-checking\">Type hints: beyond static type checking</h2>\n<p>The type-correctness is not the only use case of the type hints. Here you can find some neat projects making good use of type annotations:</p>\n<h3 id=\"pydantic\"><a href=\"https://github.com/samuelcolvin/pydantic\">Pydantic</a></h3>\n<p>This library allows you to specify and validate your data model using intuitive type-annotated classes. It’s super fast and is a foundation of FastAPI web framework (request/response models and \nvalidations).</p>\n<pre class='language-javascriptreact'><code><span class=\"hljs-keyword\">from</span> typing <span class=\"hljs-keyword\">import</span> List, Optional\n\n<span class=\"hljs-keyword\">from</span> fastapi <span class=\"hljs-keyword\">import</span> FastAPI\n<span class=\"hljs-keyword\">from</span> pydantic <span class=\"hljs-keyword\">import</span> BaseModel\n\napp = FastAPI()\n\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Item</span><span class=\"hljs-params\">(BaseModel)</span>:</span>\n    name: str\n    tax: Optional[float] = <span class=\"hljs-literal\">None</span>\n    tags: List[str] = []\n\n\n<span class=\"hljs-meta\">@app.post(\"/items/\", response_model=Item)</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">create_item</span><span class=\"hljs-params\">(item: Item)</span>:</span>\n    <span class=\"hljs-keyword\">return</span> item</code></pre><p class=\"caption\">You get request and response validation for free.</p>\n\n<h3 id=\"typer\"><a href=\"https://github.com/tiangolo/typer\">Typer</a></h3>\n<p>Generating CLIs using just type-annotated functions. Takes care of parsing, validating and generating boilerplate for you. </p>\n<h3 id=\"hypothesis\"><a href=\"https://hypothesis.readthedocs.io/en/latest/quickstart.html\">Hypothesis</a></h3>\n<p>Hypothesis is a library enabling property-based testing for pytest. Instead of crafting custom unit test examples, you specify functions generating the test cases for you. Or… you can use inferred strategies which will sample the space of all valid values for a given type!</p>\n<pre class='language-javascriptreact'><code><span class=\"hljs-keyword\">from</span> hypothesis <span class=\"hljs-keyword\">import</span> given, infer\n\n<span class=\"hljs-meta\">@given(username=infer, article_id=infer, comment=infer)</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">test_adding_comment</span><span class=\"hljs-params\">(username: str, article_id: int, comment: str)</span>:</span>\n    <span class=\"hljs-keyword\">with</span> mock_article(article_id):\n    comment_id = add_comment(username, comment)\n    <span class=\"hljs-keyword\">assert</span> comment_id <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span></code></pre><p class=\"caption\">Inferred strategies are a good start, but you should limit the search space of your examples to match your assumptions (would you expect your article_ids to be negative?)</p>\n\n<h2 id=\"outro\">Outro</h2>\n<p>Static type checking gives the developers additional layer of validation of their code against the common type errors. With the wonders of static analysis, you can significantly reduce the number of bugs, make contributing to the code easier and catch some non-trivial security issues. </p>\n<p><img src=\"https://media.giphy.com/media/l4pTjOu0NsrLApt0Q/giphy-downsized.gif\" alt=\"Thanks\"></p>\n","title":"You're my type: Python, meet static typing","tags":["blog","post"],"date":"2020-09-06T16:49:20.000Z","slug":"3-youre-my-type","image":"3-assets/shelby-miller-hL0xl0qmxYM-unsplash.jpg","author":"Tomek Dziopa","header_align":"bottom"}